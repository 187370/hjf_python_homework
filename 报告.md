# 期末大作业报告
## 简要介绍
本次大作业是针对期中量化大作业的改进版本，期中量化大作业的方法是用当前交易日期前的所有数据训练一个LSTM模型，由于每到一个交易日期，模型得重新训练一次（无法只训练一次模型，否则该模型有了所有股票全部时间段的数据，属于作弊），速度非常慢，而且由于LSTM模型本身不具有世界知识和局势判断能力，仅仅是对数据的拟合，使得其训练又慢，效果又不出众，最终期中大作业的最佳表现为收益率: 118.44%。基于以上缺点和胡老师的指引，以及我在LLM选做题上的思想，我采用了利用大模型LLM来做量化交易的办法，并结合关系建模实现研究对象之间的个性化关联关系，以及网络爬虫来改进量化大作业，最终收益率提高到了  。以下是具体创新点的介绍。
## 创新点一：每次交易并行多次调用API对股票分析并结合传统技术分析作出决策
这是最重要和花费时间最多的创新点，将主要介绍。
### 每次交易时，先利用大模型分析股票情感
我对每支股票先调用一次API（并行调用），传给API 日期信息（启发LLM结合该日期和其世界知识，判断当前日期下该股票的形势），公司背景（介绍公司基本情况），和技术分析摘要（包括最新价格，期间价格变化，价格波动率，成交量趋势比率），30天价格历史轨迹，以及当前日期下的新闻摘要（利用search.py调用朋友部署的searxng的搜索引擎实现），并让LLM以固定JSON格式（方便我们提取LLM的回答）回复评分（sentiment_score），置信度（confidence），理由（reasoning），关键因素（key_factors），风险（risk_level），价格动能（就是价格趋势price_momentum）和volume_confirmation。
### 股票情感生成后利用LLM生成交易信号



### 突破限制一：如何突破deepseek API调用速率限制
deepseek API都有速率限制，为了解决这个难题，我查询网络资料，找到了[one-hub]( https://github.com/MartialBE/one-hub) 的工作，并在我的LCPU校内服务器上部署了one-hub网站，地址为http://10.129.80.218:3000/ (可以点开查看，由于LCPU在7月底会升级服务器，期间服务器关闭十天，所以如果连接不上这个服务器，请联系我，手机号为18737096831)，通过利用服务器作为中间API服务商（本项目的API base url就是 http://10.129.80.218:3000/v1），在服务器上放多个deepseek的API key，利用onehub进行均衡负载，成功解决了API速率限制的问题。
![image-20250609150204784](报告/image-20250609150204784.png)

### 突破限制二：如何突破串行时间限制
由于每次调用API都需要等待较长时间（我在onehub后台看到，大约为11秒时间），而我们有60个交易日期，31个股票，每个股票调用两次API，共需要60*31*2*11=40920秒，约11个小时，这个时间显然是不可以接受的，我利用课堂第五讲讲的线程池的知识对API调用做了并行处理，这样时间就缩短为原来的31分之一，大概20分钟就能跑完一个测试，比原先的不并行版本和期中的训练LSTM版本（大概6小时）都快了很多！
```python
    def batch_analyze_stocks_parallel(self, analysis_tasks: List[Dict]) -> List[Dict]:
        """
        并行处理多个股票的分析任务
        Args:
            analysis_tasks: 分析任务列表，每个任务包含股票代码和相关数据
        Returns:
            分析结果列表
        """
        self.logger.info(f"开始并行分析 {len(analysis_tasks)} 个股票...")

        results = []

        # 使用线程池进行并行处理
        with ThreadPoolExecutor(
            max_workers=min(len(self.clients), len(analysis_tasks))
        ) as executor:
            # 提交所有任务
            future_to_task = {}

            for i, task in enumerate(analysis_tasks):
                client_index = i % len(self.clients)

                if task["task_type"] == "sentiment":
                    future = executor.submit(
                        self._analyze_sentiment_single,
                        task["stock_symbol"],
                        task["recent_data"],
                        task.get("news_headlines"),
                        task.get("current_date"),
                        client_index,
                    )
                elif task["task_type"] == "trading_signal":
                    future = executor.submit(
                        self._generate_trading_signal_single,
                        task["stock_symbol"],
                        task["technical_indicators"],
                        task["market_sentiment"],
                        task.get("holding_info"),
                        task.get("latest_price"),
                        client_index,
                    )

                future_to_task[future] = task

            # 收集结果
            for future in as_completed(future_to_task):
                task = future_to_task[future]
                try:
                    result = future.result()
                    results.append(
                        {
                            "stock_symbol": task["stock_symbol"],
                            "task_type": task["task_type"],
                            "result": result,
                            "success": True,
                        }
                    )
                except Exception as e:
                    self.logger.error(f"任务失败 {task['stock_symbol']}: {e}")
                    results.append(
                        {
                            "stock_symbol": task["stock_symbol"],
                            "task_type": task["task_type"],
                            "result": None,
                            "success": False,
                            "error": str(e),
                        }
                    )

        self.logger.info(
            f"并行分析完成，成功: {sum(1 for r in results if r['success'])}/{len(results)}"
        )
        return results
```
![image-20250609150223175](报告/image-20250609150223175.png)